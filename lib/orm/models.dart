import 'dart:convert';
import 'package:contabilidadapp/orm/database_model.dart';
import 'package:http/http.dart' as http;
import 'package:flutter/material.dart';
import 'package:sqfentity/sqfentity.dart';

      /*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following: 
      - import Seating.dart into where to use
      - start typing Seating().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(seating) / or toList(seatingList) 
      - you can select one Seating or List<Seating> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
      // region Seating
      class Seating {
        Seating({this.ids, this.alias,this.date}) { setDefaultValues();}
        Seating.withFields(this.alias,this.date){ setDefaultValues();}
        Seating.withId(this.ids, this.alias,this.date){ setDefaultValues();}
        Seating.fromMap(Map<String, dynamic> o) {
          ids = o["ids"] as int;
    alias = o["alias"] as String;
    date = o["date"] as String;

          }
        // FIELDS
        int ids;
      String alias;
      String date;
      // end FIELDS
        
        
// COLLECTIONS
       TransactionFilterBuilder getTransactions({List<String> columnsToSelect, bool getIsDeleted}){
       return Transaction().select(columnsToSelect: columnsToSelect,getIsDeleted: getIsDeleted).SeatingIds.equals(ids);
      }
    // END COLLECTIONS

        static const bool _softDeleteActivated=false;
        SeatingManager __mnSeating;
        SeatingFilterBuilder _select;
      
        SeatingManager get _mnSeating {
          if (__mnSeating == null) __mnSeating = SeatingManager();
          return __mnSeating;
        }
      
        // methods
        Map<String, dynamic> toMap({bool forQuery=false}) {
          final map = Map<String, dynamic>();
          if (ids != null) {map["ids"] = ids;}    if (alias != null) {map["alias"] = alias;}
    if (date != null) {map["date"] = date;}

          return map;
          }
      
        List<dynamic> toArgs() {
          return[ids,alias,date];   
        }  
    
          
        static Future<List<Seating>> fromWebUrl(String url, [VoidCallback  seatingList (List<Seating> o)]) async {
        var objList = List<Seating>();
          try {
            final response = await http.get(url);
            final Iterable list = json.decode(response.body) as Iterable;
            objList = list.map((seating) => Seating.fromMap(seating as Map<String, dynamic>)).toList();
            if(seatingList != null) {seatingList(objList);}
            return objList;
          } catch (e) {
            print("SQFENTITY ERROR Seating.fromWeb: ErrorMessage:" + e.toString());
            return null;
          }
       }
    
        static Future<List<Seating>> fromObjectList(Future<List<dynamic>> o) async {
          final seatingsList = List<Seating>();
          final data = await o;
            for (int i = 0; i < data.length; i++) {
              seatingsList.add(Seating.fromMap(data[i] as Map<String, dynamic>));
            }
          return seatingsList;
        }
      
        static List<Seating> fromMapList(List<Map<String, dynamic>> query) {
          final List<Seating> seatings = List<Seating>();
          for (Map map in query) {
            seatings.add(Seating.fromMap(map as Map<String, dynamic>));
          }
          return seatings;
        }
      

        /// returns Seating by ID if exist, otherwise returns null
        /// <param name="ids">Primary Key Value</param>
        /// <returns>returns Seating if exist, otherwise returns null</returns>
        Future<Seating> getById(int ids) async{
          Seating seatingObj;
          final data = await _mnSeating.getById(ids);
          if (data.length != 0) 
             {seatingObj = Seating.fromMap(data[0] as Map<String, dynamic>);}
          else
             {seatingObj = null;}
          return seatingObj;
        }
      
        /// <summary>
        /// Saves the object. If the ids field is null, saves as a new record and returns new ids, if ids is not null then updates record
        /// </summary>
        /// <returns>Returns ids</returns>
        Future<int> save() async {
          if (ids == null || ids == 0) {
            ids = await _mnSeating.insert(
                Seating.withFields(alias,date)); }
          else {
            ids= await _upsert(); }
          return ids;
        }
    
        /// <summary>
        /// saveAll method saves the sent List<Seating> as a batch in one transaction 
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> saveAll(List<Seating> seatings) async {
          final results = _mnSeating.saveAll("INSERT OR REPLACE INTO Seating (ids, alias,date)  VALUES (?,?,?)",seatings);
          return results;
        }
    
        /// <summary>
        /// Updates if the record exists, otherwise adds a new row
        /// </summary>
        /// <returns>Returns ids</returns>
        Future<int> _upsert() async {
          ids = await _mnSeating.rawInsert(
              "INSERT OR REPLACE INTO Seating (ids, alias,date)  VALUES (?,?,?)", [ids,alias,date]);
          return ids;
        }


        /// <summary>
        /// inserts or replaces the sent List<Todo> as a batch in one transaction.
        /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> upsertAll(List<Seating> seatings) async {
          final results = await _mnSeating.rawInsertAll(
              "INSERT OR REPLACE INTO Seating (ids, alias,date)  VALUES (?,?,?)", seatings);
          return results;
        }
    
    
        /// <summary>
        /// saveAs Seating. Returns a new Primary Key value of Seating
        /// </summary>
        /// <returns>Returns a new Primary Key value of Seating</returns>
        Future<int> saveAs() async {
          ids = await _mnSeating.insert(
              Seating.withFields(alias,date));
          return ids;
        }
      
    
        /// <summary>
        /// Deletes Seating
        /// </summary>
        /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
        Future<BoolResult> delete([bool hardDelete=false]) async {
          print("SQFENTITIY: delete Seating invoked (ids=$ids)");
          var result= BoolResult();  {result = await Transaction().select().SeatingIds.equals(ids).delete(hardDelete);}
  if (!result.success) {return result;}
        else
           if (!_softDeleteActivated || hardDelete) {
  return _mnSeating.delete(QueryParams(whereString: "ids=$ids"));}
  else {
  return _mnSeating.updateBatch(QueryParams(whereString: "ids=$ids"), {"isDeleted": 1});}
        }
          
        //private SeatingFilterBuilder _Select;
        SeatingFilterBuilder select(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          _select = SeatingFilterBuilder(this);
          _select._getIsDeleted = getIsDeleted==true;
          _select.qparams.selectColumns = columnsToSelect;
          return _select;
        }
      
        SeatingFilterBuilder distinct(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          final SeatingFilterBuilder _distinct = SeatingFilterBuilder(this);
          _distinct._getIsDeleted = getIsDeleted==true;
          _distinct.qparams.selectColumns = columnsToSelect;
          _distinct.qparams.distinct = true;
          return _distinct;
        }
      
        void setDefaultValues() {
          
        }
        //end methods
      }
      // endregion seating
      
          
// region SeatingField
class SeatingField extends SearchCriteria {
  SeatingField(this.seatingFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = "";
  SeatingFilterBuilder seatingFB;
  
  SeatingField get not {
    _waitingNot = " NOT ";
    return this;
  }

  SeatingFilterBuilder equals(var pValue) {
    param.expression = "=";
    seatingFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, seatingFB.parameters, param, SqlSyntax.EQuals,
            seatingFB._addedBlocks)
        : setCriteria(pValue, seatingFB.parameters, param, SqlSyntax.NotEQuals,
            seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder isNull() {
    seatingFB._addedBlocks = setCriteria(
        0,
        seatingFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder contains(dynamic pValue) {
    seatingFB._addedBlocks = setCriteria(
        "%" + pValue.toString() + "%",
        seatingFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder startsWith(dynamic pValue) {
    seatingFB._addedBlocks = setCriteria(
        pValue.toString() + "%",
        seatingFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder endsWith(dynamic pValue) {
    seatingFB._addedBlocks = setCriteria(
        "%" + pValue.toString(),
        seatingFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      seatingFB._addedBlocks = setCriteria(
          pFirst,
          seatingFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          seatingFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "") {
        seatingFB._addedBlocks = setCriteria(pFirst, seatingFB.parameters,
            param, SqlSyntax.LessThan, seatingFB._addedBlocks); }
      else {
        seatingFB._addedBlocks = setCriteria(pFirst, seatingFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, seatingFB._addedBlocks); }
    } else if (pLast != null) {
      if (_waitingNot != "") {
        seatingFB._addedBlocks = setCriteria(pLast, seatingFB.parameters, param,
            SqlSyntax.GreaterThan, seatingFB._addedBlocks);}
      else {
        seatingFB._addedBlocks = setCriteria(pLast, seatingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, seatingFB._addedBlocks); }
    }
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    seatingFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.GreaterThan, seatingFB._addedBlocks)
        : setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    seatingFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, seatingFB.parameters, param, SqlSyntax.LessThan,
            seatingFB._addedBlocks)
        : setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    seatingFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, seatingFB._addedBlocks)
        : setCriteria(pValue, seatingFB.parameters, param, SqlSyntax.LessThan,
            seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    seatingFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, seatingFB._addedBlocks)
        : setCriteria(pValue, seatingFB.parameters, param,
            SqlSyntax.GreaterThan, seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }

  SeatingFilterBuilder inValues(var pValue) {
    seatingFB._addedBlocks = setCriteria(
        pValue,
        seatingFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        seatingFB._addedBlocks);
    _waitingNot = "";
    seatingFB._addedBlocks.needEndBlock[seatingFB._blockIndex] =
        seatingFB._addedBlocks.retVal;
    return seatingFB;
  }
}
// endregion SeatingField

       // region SeatingFilterBuilder
   class SeatingFilterBuilder extends SearchCriteria {
     SeatingFilterBuilder(Seating obj) {
       whereString = "";
       qparams = QueryParams();
       parameters = List<DbParameter>();
       orderByList = List<String>();
       groupByList = List<String>();
       _addedBlocks = AddedBlocks(List<bool>(), List<bool>());
       _addedBlocks.needEndBlock.add(false);
       _addedBlocks.waitingStartBlock.add(false);
       _pagesize = 0;
       _page = 0;
       _obj = obj;
     }
     AddedBlocks _addedBlocks;
     int _blockIndex = 0;
     List<DbParameter> parameters;
     List<String> orderByList;
     Seating _obj;
     QueryParams qparams;
     int _pagesize;
     int _page;

   
     SeatingFilterBuilder get and {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " AND ";}
       return this;
     }
   
     SeatingFilterBuilder get or {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " OR ";}
       return this;
     }
   
     SeatingFilterBuilder get startBlock {
       _addedBlocks.waitingStartBlock.add(true);
       _addedBlocks.needEndBlock.add(false);
       _blockIndex++;
       if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
       return this;
     }
   
     SeatingFilterBuilder where(String whereCriteria) {
       if (whereCriteria != null && whereCriteria != "") {
         final DbParameter param = DbParameter();
         _addedBlocks = setCriteria(
             0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
         _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
       }
       return this;
     }
   
     SeatingFilterBuilder page(int page, int pagesize) {
       if (page > 0) _page = page;
       if (pagesize > 0) _pagesize = pagesize;
       return this;
     }
   
     SeatingFilterBuilder top(int count) {
       if (count > 0) {
         _pagesize = count;
       }
       return this;
     }
   
     SeatingFilterBuilder get endBlock {
       if (_addedBlocks.needEndBlock[_blockIndex]) {
         parameters[parameters.length - 1].whereString += " ) ";
       }
       _addedBlocks.needEndBlock.removeAt(_blockIndex);
       _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
       _blockIndex--;
       return this;
     }
   
     SeatingFilterBuilder orderBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add(argFields); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s ");
           } }
       }
       return this;
     }
   
     SeatingFilterBuilder orderByDesc(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add("$argFields desc "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s desc ");
           } }
       }
       return this;
     }
   
     SeatingFilterBuilder groupBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           groupByList.add(" $argFields "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") groupByList.add(" $s ");
           } }
       }
       return this;
     }
   
     SeatingField setField(SeatingField field, String colName, DbType dbtype) {
       field = SeatingField(this);
       field.param = DbParameter(
           dbType: dbtype,
           columnName: colName,
           wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
       return field;
     }
   
            SeatingField _ids;
     SeatingField get ids {
       _ids = setField(_ids, "ids", DbType.integer);
       return _ids;
     }
                SeatingField _alias;
     SeatingField get alias {
       _alias = setField(_alias, "alias", DbType.text);
       return _alias;
     }
                SeatingField _date;
     SeatingField get date {
       _date = setField(_date, "date", DbType.text);
       return _date;
     }
       
   
     bool _getIsDeleted;
   
     void _buildParameters() {
       if (_page > 0 && _pagesize > 0) {
         qparams.limit = _pagesize;
         qparams.offset = (_page - 1) * _pagesize;
       } else {
         qparams.limit = _pagesize;
         qparams.offset = _page;
       }
       for (DbParameter param in parameters) {
         if (param.columnName != null) {
           if (param.value is List) {
             param.value = param.value
                 .toString()
                 .replaceAll("[", "")
                 .replaceAll("]", "")
                 .toString();
             whereString += param.whereString
                 .replaceAll("{field}", param.columnName)
                 .replaceAll("?", param.value.toString());
             param.value = null;
           } else {
             whereString +=
                 param.whereString.replaceAll("{field}", param.columnName); }
           switch (param.dbType) {
             case DbType.bool:
               if (param.value != null) param.value = param.value == true ? 1 : 0;
               break;
             default:
           }
   
           if (param.value != null) whereArguments.add(param.value);
           if (param.value2 != null) whereArguments.add(param.value2);
         } else {
           whereString += param.whereString;}
       }
       if (Seating._softDeleteActivated) {
         if (whereString != "") {
           whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
               " ($whereString)";}
         else if (!_getIsDeleted) {whereString = "ifnull(isDeleted,0)=0";}
       }
   
       if (whereString != "") {qparams.whereString = whereString;}
       qparams.whereArguments = whereArguments;
       qparams.groupBy = groupByList.join(',');
       qparams.orderBy = orderByList.join(',');
     }
   
     
    /// <summary>
    /// Deletes List<Seating> batch by query 
    /// </summary>
    /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
    Future<BoolResult> delete([bool hardDelete=false]) async {
      _buildParameters();
      var r= BoolResult();
        if(Seating._softDeleteActivated && !hardDelete) {
          r = await _obj._mnSeating.updateBatch(qparams,{"isDeleted":1}); }
      else {
          r = await _obj._mnSeating.delete(qparams); }
      return r;    
    }
     
    
     Future<BoolResult> update(Map<String, dynamic> values) {
       _buildParameters();
       return _obj._mnSeating.updateBatch(qparams, values);
     }
   
     /// This method always returns SeatingObj if exist, otherwise returns null 
     /// <returns>List<Seating></returns>
     Future<Seating> toSingle([VoidCallback seating(Seating o)]) async{
       _pagesize = 1;
       _buildParameters();
       final objFuture = _obj._mnSeating.toList(qparams);
       final data = await objFuture;
       Seating retVal;
       if (data.isNotEmpty) { retVal = Seating.fromMap(data[0] as Map<String, dynamic>); } else {retVal = null;}
          if(seating!=null) {seating(retVal);}
       return retVal;
     }
     
   
      /// This method always returns int.
      /// <returns>int</returns>
      Future<BoolResult> toCount(VoidCallback seatingCount (int c)) async {
       _buildParameters();
       qparams.selectColumns = ["COUNT(1) AS CNT"];   
       final seatingsFuture = await _obj._mnSeating.toList(qparams);
       final int count = seatingsFuture[0]["CNT"] as int;
       seatingCount (count);
       return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
     }
      
     /// This method always returns List<Seating>. 
     /// <returns>List<Seating></returns>
     Future<List<Seating>> toList([VoidCallback seatingList (List<Seating> o)]) async {
   
       _buildParameters();
       final seatingsFuture = _obj._mnSeating.toList(qparams);
       final List<Seating> seatingsData = List<Seating>();
       final data = await seatingsFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           seatingsData.add(Seating.fromMap(data[i] as Map<String, dynamic>));
         }
         if (seatingList != null) seatingList (seatingsData);
         return seatingsData;
     }
  
    
        /// Returns List<DropdownMenuItem<Seating>>
        Future<List<DropdownMenuItem<Seating>>> toDropDownMenu(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<Seating>> o)]) async {
          _buildParameters();
          final seatingsFuture = _obj._mnSeating.toList(qparams);

          final data = await seatingsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<Seating>> items = List();
          items.add(DropdownMenuItem(
            value: Seating(),
            child: Text("Select Seating"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: Seating.fromMap(data[i] as Map<String, dynamic>),
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }

        /// Returns List<DropdownMenuItem<int>>
        Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<int>> o)]) async {
          _buildParameters();
          qparams.selectColumns=["ids",displayTextColumn];
          final seatingsFuture = _obj._mnSeating.toList(qparams);

          final data = await seatingsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<int>> items = List();
          items.add(DropdownMenuItem(
            value: 0,
            child: Text("Select Seating"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: data[i]["ids"] as int,
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }


     /// This method always returns Primary Key List<int>. 
     /// <returns>List<int></returns>
     Future<List<int>> toListPrimaryKey([VoidCallback idsList (List<int> o),
           bool buildParameters=true]) async {
       if(buildParameters) _buildParameters();
       final List<int> idsData = List<int>();
       qparams.selectColumns= ["ids"];
       final idsFuture = await _obj._mnSeating.toList(qparams);
   

         final int count = idsFuture.length;
         for (int i = 0; i < count; i++) {
           idsData.add(idsFuture[i]["ids"] as int);
         }
         if(idsList != null) {idsList (idsData);}
         return idsData;

     }
  
    /// Returns List<dynamic> for selected columns. Use this method for "groupBy" with min,max,avg.. 
    /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)  
     Future<List<dynamic>> toListObject([VoidCallback listObject(List<dynamic> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnSeating.toList(qparams);
   
       final List<dynamic> objectsData = List<dynamic>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i]);
         }
         if (listObject != null) {listObject(objectsData);}
         return objectsData;

     }

    /// Returns List<String> for selected first column
    /// Sample usage: await Seating.select(columnsToSelect: ["columnName"]).toListString()
     Future<List<String>> toListString([VoidCallback listString(List<String> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnSeating.toList(qparams);
   
       final List<String> objectsData = List<String>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i][qparams.selectColumns[0]].toString());
         }
         if (listString != null) {listString(objectsData);}
         return objectsData;

     }
   }
   // endregion SeatingFilterBuilder
       
       


// region SeatingFields
class SeatingFields {
  static TableField _fIds;
  static TableField get ids {
    _fIds = SqlSyntax.setField(_fIds, "ids", DbType.integer);
    return _fIds;
  }
  static TableField _fAlias;
  static TableField get alias {
    _fAlias = SqlSyntax.setField(_fAlias, "alias", DbType.text);
    return _fAlias;
  }
  static TableField _fDate;
  static TableField get date {
    _fDate = SqlSyntax.setField(_fDate, "date", DbType.text);
    return _fDate;
  }

}
// endregion SeatingFields

//region SeatingManager
class SeatingManager extends SqfEntityProvider {
  SeatingManager():super(DatabaseModel(),tableName: _tableName, colId: _colId);
  static String _tableName = "Seating";
  static String _colId = "ids";
 
}
//endregion SeatingManager


      /*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following: 
      - import Transaction.dart into where to use
      - start typing Transaction().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(transaction) / or toList(transactionList) 
      - you can select one Transaction or List<Transaction> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
      // region Transaction
      class Transaction {
        Transaction({this.idtr, this.name,this.price,this.TypxIdt,this.SeatingIds}) { setDefaultValues();}
        Transaction.withFields(this.name,this.price,this.TypxIdt,this.SeatingIds){ setDefaultValues();}
        Transaction.withId(this.idtr, this.name,this.price,this.TypxIdt,this.SeatingIds){ setDefaultValues();}
        Transaction.fromMap(Map<String, dynamic> o) {
          idtr = o["idtr"] as int;
    name = o["name"] as String;
    price = o["price"] as double;
    TypxIdt = o["TypxIdt"] as int;
    SeatingIds = o["SeatingIds"] as int;

          }
        // FIELDS
        int idtr;
      String name;
      double price;
      int TypxIdt;
      int SeatingIds;
      // end FIELDS
        
// RELATIONSHIPS
     Future<Typx> getTypx([VoidCallback typx(Typx o)]) async{
        final obj = await Typx().getById(TypxIdt);
        if(typx != null){
           typx(obj);
          }
        return obj;
      }
         Future<Seating> getSeating([VoidCallback seating(Seating o)]) async{
        final obj = await Seating().getById(SeatingIds);
        if(seating != null){
           seating(obj);
          }
        return obj;
      }
    // END RELATIONSHIPS

        
        static const bool _softDeleteActivated=false;
        TransactionManager __mnTransaction;
        TransactionFilterBuilder _select;
      
        TransactionManager get _mnTransaction {
          if (__mnTransaction == null) __mnTransaction = TransactionManager();
          return __mnTransaction;
        }
      
        // methods
        Map<String, dynamic> toMap({bool forQuery=false}) {
          final map = Map<String, dynamic>();
          if (idtr != null) {map["idtr"] = idtr;}    if (name != null) {map["name"] = name;}
    if (price != null) {map["price"] = price;}
    if (TypxIdt != null) {map["TypxIdt"] = TypxIdt;}
    if (SeatingIds != null) {map["SeatingIds"] = SeatingIds;}

          return map;
          }
      
        List<dynamic> toArgs() {
          return[idtr,name,price,TypxIdt,SeatingIds];   
        }  
    
          
        static Future<List<Transaction>> fromWebUrl(String url, [VoidCallback  transactionList (List<Transaction> o)]) async {
        var objList = List<Transaction>();
          try {
            final response = await http.get(url);
            final Iterable list = json.decode(response.body) as Iterable;
            objList = list.map((transaction) => Transaction.fromMap(transaction as Map<String, dynamic>)).toList();
            if(transactionList != null) {transactionList(objList);}
            return objList;
          } catch (e) {
            print("SQFENTITY ERROR Transaction.fromWeb: ErrorMessage:" + e.toString());
            return null;
          }
       }
    
        static Future<List<Transaction>> fromObjectList(Future<List<dynamic>> o) async {
          final transactionsList = List<Transaction>();
          final data = await o;
            for (int i = 0; i < data.length; i++) {
              transactionsList.add(Transaction.fromMap(data[i] as Map<String, dynamic>));
            }
          return transactionsList;
        }
      
        static List<Transaction> fromMapList(List<Map<String, dynamic>> query) {
          final List<Transaction> transactions = List<Transaction>();
          for (Map map in query) {
            transactions.add(Transaction.fromMap(map as Map<String, dynamic>));
          }
          return transactions;
        }
      

        /// returns Transaction by ID if exist, otherwise returns null
        /// <param name="idtr">Primary Key Value</param>
        /// <returns>returns Transaction if exist, otherwise returns null</returns>
        Future<Transaction> getById(int idtr) async{
          Transaction transactionObj;
          final data = await _mnTransaction.getById(idtr);
          if (data.length != 0) 
             {transactionObj = Transaction.fromMap(data[0] as Map<String, dynamic>);}
          else
             {transactionObj = null;}
          return transactionObj;
        }
      
        /// <summary>
        /// Saves the object. If the idtr field is null, saves as a new record and returns new idtr, if idtr is not null then updates record
        /// </summary>
        /// <returns>Returns idtr</returns>
        Future<int> save() async {
          if (idtr == null || idtr == 0) {
            idtr = await _mnTransaction.insert(
                Transaction.withFields(name,price,TypxIdt,SeatingIds)); }
          else {
            idtr= await _upsert(); }
          return idtr;
        }
    
        /// <summary>
        /// saveAll method saves the sent List<Transaction> as a batch in one transaction 
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> saveAll(List<Transaction> transactions) async {
          final results = _mnTransaction.saveAll("INSERT OR REPLACE INTO Transactions (idtr, name,price,TypxIdt,SeatingIds)  VALUES (?,?,?,?,?)",transactions);
          return results;
        }
    
        /// <summary>
        /// Updates if the record exists, otherwise adds a new row
        /// </summary>
        /// <returns>Returns idtr</returns>
        Future<int> _upsert() async {
          idtr = await _mnTransaction.rawInsert(
              "INSERT OR REPLACE INTO Transactions (idtr, name,price,TypxIdt,SeatingIds)  VALUES (?,?,?,?,?)", [idtr,name,price,TypxIdt,SeatingIds]);
          return idtr;
        }


        /// <summary>
        /// inserts or replaces the sent List<Todo> as a batch in one transaction.
        /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> upsertAll(List<Transaction> transactions) async {
          final results = await _mnTransaction.rawInsertAll(
              "INSERT OR REPLACE INTO Transactions (idtr, name,price,TypxIdt,SeatingIds)  VALUES (?,?,?,?,?)", transactions);
          return results;
        }
    
    
        /// <summary>
        /// saveAs Transaction. Returns a new Primary Key value of Transaction
        /// </summary>
        /// <returns>Returns a new Primary Key value of Transaction</returns>
        Future<int> saveAs() async {
          idtr = await _mnTransaction.insert(
              Transaction.withFields(name,price,TypxIdt,SeatingIds));
          return idtr;
        }
      
    
        /// <summary>
        /// Deletes Transaction
        /// </summary>
        /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
        Future<BoolResult> delete([bool hardDelete=false]) async {
          print("SQFENTITIY: delete Transaction invoked (idtr=$idtr)");
            if (!_softDeleteActivated || hardDelete) {
  return _mnTransaction.delete(QueryParams(whereString: "idtr=$idtr"));}
  else {
  return _mnTransaction.updateBatch(QueryParams(whereString: "idtr=$idtr"), {"isDeleted": 1});}
        }
          
        //private TransactionFilterBuilder _Select;
        TransactionFilterBuilder select(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          _select = TransactionFilterBuilder(this);
          _select._getIsDeleted = getIsDeleted==true;
          _select.qparams.selectColumns = columnsToSelect;
          return _select;
        }
      
        TransactionFilterBuilder distinct(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          final TransactionFilterBuilder _distinct = TransactionFilterBuilder(this);
          _distinct._getIsDeleted = getIsDeleted==true;
          _distinct.qparams.selectColumns = columnsToSelect;
          _distinct.qparams.distinct = true;
          return _distinct;
        }
      
        void setDefaultValues() {
          if(price==null) price=0;

        }
        //end methods
      }
      // endregion transaction
      
          
// region TransactionField
class TransactionField extends SearchCriteria {
  TransactionField(this.transactionFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = "";
  TransactionFilterBuilder transactionFB;
  
  TransactionField get not {
    _waitingNot = " NOT ";
    return this;
  }

  TransactionFilterBuilder equals(var pValue) {
    param.expression = "=";
    transactionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, transactionFB.parameters, param, SqlSyntax.EQuals,
            transactionFB._addedBlocks)
        : setCriteria(pValue, transactionFB.parameters, param, SqlSyntax.NotEQuals,
            transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder isNull() {
    transactionFB._addedBlocks = setCriteria(
        0,
        transactionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder contains(dynamic pValue) {
    transactionFB._addedBlocks = setCriteria(
        "%" + pValue.toString() + "%",
        transactionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder startsWith(dynamic pValue) {
    transactionFB._addedBlocks = setCriteria(
        pValue.toString() + "%",
        transactionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder endsWith(dynamic pValue) {
    transactionFB._addedBlocks = setCriteria(
        "%" + pValue.toString(),
        transactionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      transactionFB._addedBlocks = setCriteria(
          pFirst,
          transactionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          transactionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "") {
        transactionFB._addedBlocks = setCriteria(pFirst, transactionFB.parameters,
            param, SqlSyntax.LessThan, transactionFB._addedBlocks); }
      else {
        transactionFB._addedBlocks = setCriteria(pFirst, transactionFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, transactionFB._addedBlocks); }
    } else if (pLast != null) {
      if (_waitingNot != "") {
        transactionFB._addedBlocks = setCriteria(pLast, transactionFB.parameters, param,
            SqlSyntax.GreaterThan, transactionFB._addedBlocks);}
      else {
        transactionFB._addedBlocks = setCriteria(pLast, transactionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, transactionFB._addedBlocks); }
    }
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    transactionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.GreaterThan, transactionFB._addedBlocks)
        : setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    transactionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, transactionFB.parameters, param, SqlSyntax.LessThan,
            transactionFB._addedBlocks)
        : setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    transactionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, transactionFB._addedBlocks)
        : setCriteria(pValue, transactionFB.parameters, param, SqlSyntax.LessThan,
            transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    transactionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, transactionFB._addedBlocks)
        : setCriteria(pValue, transactionFB.parameters, param,
            SqlSyntax.GreaterThan, transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }

  TransactionFilterBuilder inValues(var pValue) {
    transactionFB._addedBlocks = setCriteria(
        pValue,
        transactionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        transactionFB._addedBlocks);
    _waitingNot = "";
    transactionFB._addedBlocks.needEndBlock[transactionFB._blockIndex] =
        transactionFB._addedBlocks.retVal;
    return transactionFB;
  }
}
// endregion TransactionField

       // region TransactionFilterBuilder
   class TransactionFilterBuilder extends SearchCriteria {
     TransactionFilterBuilder(Transaction obj) {
       whereString = "";
       qparams = QueryParams();
       parameters = List<DbParameter>();
       orderByList = List<String>();
       groupByList = List<String>();
       _addedBlocks = AddedBlocks(List<bool>(), List<bool>());
       _addedBlocks.needEndBlock.add(false);
       _addedBlocks.waitingStartBlock.add(false);
       _pagesize = 0;
       _page = 0;
       _obj = obj;
     }
     AddedBlocks _addedBlocks;
     int _blockIndex = 0;
     List<DbParameter> parameters;
     List<String> orderByList;
     Transaction _obj;
     QueryParams qparams;
     int _pagesize;
     int _page;

   
     TransactionFilterBuilder get and {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " AND ";}
       return this;
     }
   
     TransactionFilterBuilder get or {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " OR ";}
       return this;
     }
   
     TransactionFilterBuilder get startBlock {
       _addedBlocks.waitingStartBlock.add(true);
       _addedBlocks.needEndBlock.add(false);
       _blockIndex++;
       if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
       return this;
     }
   
     TransactionFilterBuilder where(String whereCriteria) {
       if (whereCriteria != null && whereCriteria != "") {
         final DbParameter param = DbParameter();
         _addedBlocks = setCriteria(
             0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
         _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
       }
       return this;
     }
   
     TransactionFilterBuilder page(int page, int pagesize) {
       if (page > 0) _page = page;
       if (pagesize > 0) _pagesize = pagesize;
       return this;
     }
   
     TransactionFilterBuilder top(int count) {
       if (count > 0) {
         _pagesize = count;
       }
       return this;
     }
   
     TransactionFilterBuilder get endBlock {
       if (_addedBlocks.needEndBlock[_blockIndex]) {
         parameters[parameters.length - 1].whereString += " ) ";
       }
       _addedBlocks.needEndBlock.removeAt(_blockIndex);
       _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
       _blockIndex--;
       return this;
     }
   
     TransactionFilterBuilder orderBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add(argFields); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s ");
           } }
       }
       return this;
     }
   
     TransactionFilterBuilder orderByDesc(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add("$argFields desc "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s desc ");
           } }
       }
       return this;
     }
   
     TransactionFilterBuilder groupBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           groupByList.add(" $argFields "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") groupByList.add(" $s ");
           } }
       }
       return this;
     }
   
     TransactionField setField(TransactionField field, String colName, DbType dbtype) {
       field = TransactionField(this);
       field.param = DbParameter(
           dbType: dbtype,
           columnName: colName,
           wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
       return field;
     }
   
            TransactionField _idtr;
     TransactionField get idtr {
       _idtr = setField(_idtr, "idtr", DbType.integer);
       return _idtr;
     }
                TransactionField _name;
     TransactionField get name {
       _name = setField(_name, "name", DbType.text);
       return _name;
     }
                TransactionField _price;
     TransactionField get price {
       _price = setField(_price, "price", DbType.real);
       return _price;
     }
                TransactionField _TypxIdt;
     TransactionField get TypxIdt {
       _TypxIdt = setField(_TypxIdt, "TypxIdt", DbType.integer);
       return _TypxIdt;
     }
                TransactionField _SeatingIds;
     TransactionField get SeatingIds {
       _SeatingIds = setField(_SeatingIds, "SeatingIds", DbType.integer);
       return _SeatingIds;
     }
       
   
     bool _getIsDeleted;
   
     void _buildParameters() {
       if (_page > 0 && _pagesize > 0) {
         qparams.limit = _pagesize;
         qparams.offset = (_page - 1) * _pagesize;
       } else {
         qparams.limit = _pagesize;
         qparams.offset = _page;
       }
       for (DbParameter param in parameters) {
         if (param.columnName != null) {
           if (param.value is List) {
             param.value = param.value
                 .toString()
                 .replaceAll("[", "")
                 .replaceAll("]", "")
                 .toString();
             whereString += param.whereString
                 .replaceAll("{field}", param.columnName)
                 .replaceAll("?", param.value.toString());
             param.value = null;
           } else {
             whereString +=
                 param.whereString.replaceAll("{field}", param.columnName); }
           switch (param.dbType) {
             case DbType.bool:
               if (param.value != null) param.value = param.value == true ? 1 : 0;
               break;
             default:
           }
   
           if (param.value != null) whereArguments.add(param.value);
           if (param.value2 != null) whereArguments.add(param.value2);
         } else {
           whereString += param.whereString;}
       }
       if (Transaction._softDeleteActivated) {
         if (whereString != "") {
           whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
               " ($whereString)";}
         else if (!_getIsDeleted) {whereString = "ifnull(isDeleted,0)=0";}
       }
   
       if (whereString != "") {qparams.whereString = whereString;}
       qparams.whereArguments = whereArguments;
       qparams.groupBy = groupByList.join(',');
       qparams.orderBy = orderByList.join(',');
     }
   
     
    /// <summary>
    /// Deletes List<Transaction> batch by query 
    /// </summary>
    /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
    Future<BoolResult> delete([bool hardDelete=false]) async {
      _buildParameters();
      var r= BoolResult();
        if(Transaction._softDeleteActivated && !hardDelete) {
          r = await _obj._mnTransaction.updateBatch(qparams,{"isDeleted":1}); }
      else {
          r = await _obj._mnTransaction.delete(qparams); }
      return r;    
    }
     
    
     Future<BoolResult> update(Map<String, dynamic> values) {
       _buildParameters();
       return _obj._mnTransaction.updateBatch(qparams, values);
     }
   
     /// This method always returns TransactionObj if exist, otherwise returns null 
     /// <returns>List<Transaction></returns>
     Future<Transaction> toSingle([VoidCallback transaction(Transaction o)]) async{
       _pagesize = 1;
       _buildParameters();
       final objFuture = _obj._mnTransaction.toList(qparams);
       final data = await objFuture;
       Transaction retVal;
       if (data.isNotEmpty) { retVal = Transaction.fromMap(data[0] as Map<String, dynamic>); } else {retVal = null;}
          if(transaction!=null) {transaction(retVal);}
       return retVal;
     }
     
   
      /// This method always returns int.
      /// <returns>int</returns>
      Future<BoolResult> toCount(VoidCallback transactionCount (int c)) async {
       _buildParameters();
       qparams.selectColumns = ["COUNT(1) AS CNT"];   
       final transactionsFuture = await _obj._mnTransaction.toList(qparams);
       final int count = transactionsFuture[0]["CNT"] as int;
       transactionCount (count);
       return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
     }
      
     /// This method always returns List<Transaction>. 
     /// <returns>List<Transaction></returns>
     Future<List<Transaction>> toList([VoidCallback transactionList (List<Transaction> o)]) async {
   
       _buildParameters();
       final transactionsFuture = _obj._mnTransaction.toList(qparams);
       final List<Transaction> transactionsData = List<Transaction>();
       final data = await transactionsFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           transactionsData.add(Transaction.fromMap(data[i] as Map<String, dynamic>));
         }
         if (transactionList != null) transactionList (transactionsData);
         return transactionsData;
     }
  
    
        /// Returns List<DropdownMenuItem<Transaction>>
        Future<List<DropdownMenuItem<Transaction>>> toDropDownMenu(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<Transaction>> o)]) async {
          _buildParameters();
          final transactionsFuture = _obj._mnTransaction.toList(qparams);

          final data = await transactionsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<Transaction>> items = List();
          items.add(DropdownMenuItem(
            value: Transaction(),
            child: Text("Select Transaction"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: Transaction.fromMap(data[i] as Map<String, dynamic>),
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }

        /// Returns List<DropdownMenuItem<int>>
        Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<int>> o)]) async {
          _buildParameters();
          qparams.selectColumns=["idtr",displayTextColumn];
          final transactionsFuture = _obj._mnTransaction.toList(qparams);

          final data = await transactionsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<int>> items = List();
          items.add(DropdownMenuItem(
            value: 0,
            child: Text("Select Transaction"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: data[i]["idtr"] as int,
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }


     /// This method always returns Primary Key List<int>. 
     /// <returns>List<int></returns>
     Future<List<int>> toListPrimaryKey([VoidCallback idtrList (List<int> o),
           bool buildParameters=true]) async {
       if(buildParameters) _buildParameters();
       final List<int> idtrData = List<int>();
       qparams.selectColumns= ["idtr"];
       final idtrFuture = await _obj._mnTransaction.toList(qparams);
   

         final int count = idtrFuture.length;
         for (int i = 0; i < count; i++) {
           idtrData.add(idtrFuture[i]["idtr"] as int);
         }
         if(idtrList != null) {idtrList (idtrData);}
         return idtrData;

     }
  
    /// Returns List<dynamic> for selected columns. Use this method for "groupBy" with min,max,avg.. 
    /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)  
     Future<List<dynamic>> toListObject([VoidCallback listObject(List<dynamic> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnTransaction.toList(qparams);
   
       final List<dynamic> objectsData = List<dynamic>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i]);
         }
         if (listObject != null) {listObject(objectsData);}
         return objectsData;

     }

    /// Returns List<String> for selected first column
    /// Sample usage: await Transaction.select(columnsToSelect: ["columnName"]).toListString()
     Future<List<String>> toListString([VoidCallback listString(List<String> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnTransaction.toList(qparams);
   
       final List<String> objectsData = List<String>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i][qparams.selectColumns[0]].toString());
         }
         if (listString != null) {listString(objectsData);}
         return objectsData;

     }
   }
   // endregion TransactionFilterBuilder
       
       


// region TransactionFields
class TransactionFields {
  static TableField _fIdtr;
  static TableField get idtr {
    _fIdtr = SqlSyntax.setField(_fIdtr, "idtr", DbType.integer);
    return _fIdtr;
  }
  static TableField _fName;
  static TableField get name {
    _fName = SqlSyntax.setField(_fName, "name", DbType.text);
    return _fName;
  }
  static TableField _fPrice;
  static TableField get price {
    _fPrice = SqlSyntax.setField(_fPrice, "price", DbType.real);
    return _fPrice;
  }
  static TableField _fTypxIdt;
  static TableField get TypxIdt {
    _fTypxIdt = SqlSyntax.setField(_fTypxIdt, "TypxIdt", DbType.integer);
    return _fTypxIdt;
  }
  static TableField _fSeatingIds;
  static TableField get SeatingIds {
    _fSeatingIds = SqlSyntax.setField(_fSeatingIds, "SeatingIds", DbType.integer);
    return _fSeatingIds;
  }

}
// endregion TransactionFields

//region TransactionManager
class TransactionManager extends SqfEntityProvider {
  TransactionManager():super(DatabaseModel(),tableName: _tableName, colId: _colId);
  static String _tableName = "Transactions";
  static String _colId = "idtr";
 
}
//endregion TransactionManager


      /*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following: 
      - import Typx.dart into where to use
      - start typing Typx().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(typx) / or toList(typxList) 
      - you can select one Typx or List<Typx> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
      // region Typx
      class Typx {
        Typx({this.idt, this.name,this.type,this.subType,this.natural}) { setDefaultValues();}
        Typx.withFields(this.name,this.type,this.subType,this.natural){ setDefaultValues();}
        Typx.withId(this.idt, this.name,this.type,this.subType,this.natural){ setDefaultValues();}
        Typx.fromMap(Map<String, dynamic> o) {
          idt = o["idt"] as int;
    name = o["name"] as String;
    type = o["type"] as String;
    subType = o["subType"] as String;
    natural = o["natural"] as String;

          }
        // FIELDS
        int idt;
      String name;
      String type;
      String subType;
      String natural;
      // end FIELDS
        
        
// COLLECTIONS
       TransactionFilterBuilder getTransactions({List<String> columnsToSelect, bool getIsDeleted}){
       return Transaction().select(columnsToSelect: columnsToSelect,getIsDeleted: getIsDeleted).TypxIdt.equals(idt);
      }
    // END COLLECTIONS

        static const bool _softDeleteActivated=false;
        TypxManager __mnTypx;
        TypxFilterBuilder _select;
      
        TypxManager get _mnTypx {
          if (__mnTypx == null) __mnTypx = TypxManager();
          return __mnTypx;
        }
      
        // methods
        Map<String, dynamic> toMap({bool forQuery=false}) {
          final map = Map<String, dynamic>();
          if (idt != null) {map["idt"] = idt;}    if (name != null) {map["name"] = name;}
    if (type != null) {map["type"] = type;}
    if (subType != null) {map["subType"] = subType;}
    if (natural != null) {map["natural"] = natural;}

          return map;
          }
      
        List<dynamic> toArgs() {
          return[idt,name,type,subType,natural];   
        }  
    
          
        static Future<List<Typx>> fromWebUrl(String url, [VoidCallback  typxList (List<Typx> o)]) async {
        var objList = List<Typx>();
          try {
            final response = await http.get(url);
            final Iterable list = json.decode(response.body) as Iterable;
            objList = list.map((typx) => Typx.fromMap(typx as Map<String, dynamic>)).toList();
            if(typxList != null) {typxList(objList);}
            return objList;
          } catch (e) {
            print("SQFENTITY ERROR Typx.fromWeb: ErrorMessage:" + e.toString());
            return null;
          }
       }
    
        static Future<List<Typx>> fromObjectList(Future<List<dynamic>> o) async {
          final typxsList = List<Typx>();
          final data = await o;
            for (int i = 0; i < data.length; i++) {
              typxsList.add(Typx.fromMap(data[i] as Map<String, dynamic>));
            }
          return typxsList;
        }
      
        static List<Typx> fromMapList(List<Map<String, dynamic>> query) {
          final List<Typx> typxs = List<Typx>();
          for (Map map in query) {
            typxs.add(Typx.fromMap(map as Map<String, dynamic>));
          }
          return typxs;
        }
      

        /// returns Typx by ID if exist, otherwise returns null
        /// <param name="idt">Primary Key Value</param>
        /// <returns>returns Typx if exist, otherwise returns null</returns>
        Future<Typx> getById(int idt) async{
          Typx typxObj;
          final data = await _mnTypx.getById(idt);
          if (data.length != 0) 
             {typxObj = Typx.fromMap(data[0] as Map<String, dynamic>);}
          else
             {typxObj = null;}
          return typxObj;
        }
      
        /// <summary>
        /// Saves the object. If the idt field is null, saves as a new record and returns new idt, if idt is not null then updates record
        /// </summary>
        /// <returns>Returns idt</returns>
        Future<int> save() async {
          if (idt == null || idt == 0) {
            idt = await _mnTypx.insert(
                Typx.withFields(name,type,subType,natural)); }
          else {
            idt= await _upsert(); }
          return idt;
        }
    
        /// <summary>
        /// saveAll method saves the sent List<Typx> as a batch in one transaction 
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> saveAll(List<Typx> typxs) async {
          final results = _mnTypx.saveAll("INSERT OR REPLACE INTO Typx (idt, name,type,subType,natural)  VALUES (?,?,?,?,?)",typxs);
          return results;
        }
    
        /// <summary>
        /// Updates if the record exists, otherwise adds a new row
        /// </summary>
        /// <returns>Returns idt</returns>
        Future<int> _upsert() async {
          idt = await _mnTypx.rawInsert(
              "INSERT OR REPLACE INTO Typx (idt, name,type,subType,natural)  VALUES (?,?,?,?,?)", [idt,name,type,subType,natural]);
          return idt;
        }


        /// <summary>
        /// inserts or replaces the sent List<Todo> as a batch in one transaction.
        /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
        /// </summary>
        /// <returns> Returns a <List<BoolResult>> </returns>
        Future<List<BoolResult>> upsertAll(List<Typx> typxs) async {
          final results = await _mnTypx.rawInsertAll(
              "INSERT OR REPLACE INTO Typx (idt, name,type,subType,natural)  VALUES (?,?,?,?,?)", typxs);
          return results;
        }
    
    
        /// <summary>
        /// saveAs Typx. Returns a new Primary Key value of Typx
        /// </summary>
        /// <returns>Returns a new Primary Key value of Typx</returns>
        Future<int> saveAs() async {
          idt = await _mnTypx.insert(
              Typx.withFields(name,type,subType,natural));
          return idt;
        }
      
    
        /// <summary>
        /// Deletes Typx
        /// </summary>
        /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
        Future<BoolResult> delete([bool hardDelete=false]) async {
          print("SQFENTITIY: delete Typx invoked (idt=$idt)");
          var result= BoolResult();  {result = await Transaction().select().TypxIdt.equals(idt).delete(hardDelete);}
  if (!result.success) {return result;}
        else
           if (!_softDeleteActivated || hardDelete) {
  return _mnTypx.delete(QueryParams(whereString: "idt=$idt"));}
  else {
  return _mnTypx.updateBatch(QueryParams(whereString: "idt=$idt"), {"isDeleted": 1});}
        }
          
        //private TypxFilterBuilder _Select;
        TypxFilterBuilder select(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          _select = TypxFilterBuilder(this);
          _select._getIsDeleted = getIsDeleted==true;
          _select.qparams.selectColumns = columnsToSelect;
          return _select;
        }
      
        TypxFilterBuilder distinct(
            {List<String> columnsToSelect, bool getIsDeleted}) {
          final TypxFilterBuilder _distinct = TypxFilterBuilder(this);
          _distinct._getIsDeleted = getIsDeleted==true;
          _distinct.qparams.selectColumns = columnsToSelect;
          _distinct.qparams.distinct = true;
          return _distinct;
        }
      
        void setDefaultValues() {
          
        }
        //end methods
      }
      // endregion typx
      
          
// region TypxField
class TypxField extends SearchCriteria {
  TypxField(this.typxFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = "";
  TypxFilterBuilder typxFB;
  
  TypxField get not {
    _waitingNot = " NOT ";
    return this;
  }

  TypxFilterBuilder equals(var pValue) {
    param.expression = "=";
    typxFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, typxFB.parameters, param, SqlSyntax.EQuals,
            typxFB._addedBlocks)
        : setCriteria(pValue, typxFB.parameters, param, SqlSyntax.NotEQuals,
            typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder isNull() {
    typxFB._addedBlocks = setCriteria(
        0,
        typxFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder contains(dynamic pValue) {
    typxFB._addedBlocks = setCriteria(
        "%" + pValue.toString() + "%",
        typxFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder startsWith(dynamic pValue) {
    typxFB._addedBlocks = setCriteria(
        pValue.toString() + "%",
        typxFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder endsWith(dynamic pValue) {
    typxFB._addedBlocks = setCriteria(
        "%" + pValue.toString(),
        typxFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      typxFB._addedBlocks = setCriteria(
          pFirst,
          typxFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          typxFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "") {
        typxFB._addedBlocks = setCriteria(pFirst, typxFB.parameters,
            param, SqlSyntax.LessThan, typxFB._addedBlocks); }
      else {
        typxFB._addedBlocks = setCriteria(pFirst, typxFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, typxFB._addedBlocks); }
    } else if (pLast != null) {
      if (_waitingNot != "") {
        typxFB._addedBlocks = setCriteria(pLast, typxFB.parameters, param,
            SqlSyntax.GreaterThan, typxFB._addedBlocks);}
      else {
        typxFB._addedBlocks = setCriteria(pLast, typxFB.parameters, param,
            SqlSyntax.LessThanOrEquals, typxFB._addedBlocks); }
    }
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    typxFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.GreaterThan, typxFB._addedBlocks)
        : setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.LessThanOrEquals, typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    typxFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, typxFB.parameters, param, SqlSyntax.LessThan,
            typxFB._addedBlocks)
        : setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    typxFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, typxFB._addedBlocks)
        : setCriteria(pValue, typxFB.parameters, param, SqlSyntax.LessThan,
            typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    typxFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.LessThanOrEquals, typxFB._addedBlocks)
        : setCriteria(pValue, typxFB.parameters, param,
            SqlSyntax.GreaterThan, typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }

  TypxFilterBuilder inValues(var pValue) {
    typxFB._addedBlocks = setCriteria(
        pValue,
        typxFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        typxFB._addedBlocks);
    _waitingNot = "";
    typxFB._addedBlocks.needEndBlock[typxFB._blockIndex] =
        typxFB._addedBlocks.retVal;
    return typxFB;
  }
}
// endregion TypxField

       // region TypxFilterBuilder
   class TypxFilterBuilder extends SearchCriteria {
     TypxFilterBuilder(Typx obj) {
       whereString = "";
       qparams = QueryParams();
       parameters = List<DbParameter>();
       orderByList = List<String>();
       groupByList = List<String>();
       _addedBlocks = AddedBlocks(List<bool>(), List<bool>());
       _addedBlocks.needEndBlock.add(false);
       _addedBlocks.waitingStartBlock.add(false);
       _pagesize = 0;
       _page = 0;
       _obj = obj;
     }
     AddedBlocks _addedBlocks;
     int _blockIndex = 0;
     List<DbParameter> parameters;
     List<String> orderByList;
     Typx _obj;
     QueryParams qparams;
     int _pagesize;
     int _page;

   
     TypxFilterBuilder get and {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " AND ";}
       return this;
     }
   
     TypxFilterBuilder get or {
       if (parameters.isNotEmpty)
         {parameters[parameters.length - 1].wOperator = " OR ";}
       return this;
     }
   
     TypxFilterBuilder get startBlock {
       _addedBlocks.waitingStartBlock.add(true);
       _addedBlocks.needEndBlock.add(false);
       _blockIndex++;
       if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
       return this;
     }
   
     TypxFilterBuilder where(String whereCriteria) {
       if (whereCriteria != null && whereCriteria != "") {
         final DbParameter param = DbParameter();
         _addedBlocks = setCriteria(
             0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
         _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
       }
       return this;
     }
   
     TypxFilterBuilder page(int page, int pagesize) {
       if (page > 0) _page = page;
       if (pagesize > 0) _pagesize = pagesize;
       return this;
     }
   
     TypxFilterBuilder top(int count) {
       if (count > 0) {
         _pagesize = count;
       }
       return this;
     }
   
     TypxFilterBuilder get endBlock {
       if (_addedBlocks.needEndBlock[_blockIndex]) {
         parameters[parameters.length - 1].whereString += " ) ";
       }
       _addedBlocks.needEndBlock.removeAt(_blockIndex);
       _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
       _blockIndex--;
       return this;
     }
   
     TypxFilterBuilder orderBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add(argFields); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s ");
           } }
       }
       return this;
     }
   
     TypxFilterBuilder orderByDesc(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           orderByList.add("$argFields desc "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") orderByList.add(" $s desc ");
           } }
       }
       return this;
     }
   
     TypxFilterBuilder groupBy(var argFields) {
       if (argFields != null) {
         if (argFields is String) {
           groupByList.add(" $argFields "); }
         else {
           for (String s in argFields) {
             if (s != null && s != "") groupByList.add(" $s ");
           } }
       }
       return this;
     }
   
     TypxField setField(TypxField field, String colName, DbType dbtype) {
       field = TypxField(this);
       field.param = DbParameter(
           dbType: dbtype,
           columnName: colName,
           wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
       return field;
     }
   
            TypxField _idt;
     TypxField get idt {
       _idt = setField(_idt, "idt", DbType.integer);
       return _idt;
     }
                TypxField _name;
     TypxField get name {
       _name = setField(_name, "name", DbType.text);
       return _name;
     }
                TypxField _type;
     TypxField get type {
       _type = setField(_type, "type", DbType.text);
       return _type;
     }
                TypxField _subType;
     TypxField get subType {
       _subType = setField(_subType, "subType", DbType.text);
       return _subType;
     }
                TypxField _natural;
     TypxField get natural {
       _natural = setField(_natural, "natural", DbType.text);
       return _natural;
     }
       
   
     bool _getIsDeleted;
   
     void _buildParameters() {
       if (_page > 0 && _pagesize > 0) {
         qparams.limit = _pagesize;
         qparams.offset = (_page - 1) * _pagesize;
       } else {
         qparams.limit = _pagesize;
         qparams.offset = _page;
       }
       for (DbParameter param in parameters) {
         if (param.columnName != null) {
           if (param.value is List) {
             param.value = param.value
                 .toString()
                 .replaceAll("[", "")
                 .replaceAll("]", "")
                 .toString();
             whereString += param.whereString
                 .replaceAll("{field}", param.columnName)
                 .replaceAll("?", param.value.toString());
             param.value = null;
           } else {
             whereString +=
                 param.whereString.replaceAll("{field}", param.columnName); }
           switch (param.dbType) {
             case DbType.bool:
               if (param.value != null) param.value = param.value == true ? 1 : 0;
               break;
             default:
           }
   
           if (param.value != null) whereArguments.add(param.value);
           if (param.value2 != null) whereArguments.add(param.value2);
         } else {
           whereString += param.whereString;}
       }
       if (Typx._softDeleteActivated) {
         if (whereString != "") {
           whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
               " ($whereString)";}
         else if (!_getIsDeleted) {whereString = "ifnull(isDeleted,0)=0";}
       }
   
       if (whereString != "") {qparams.whereString = whereString;}
       qparams.whereArguments = whereArguments;
       qparams.groupBy = groupByList.join(',');
       qparams.orderBy = orderByList.join(',');
     }
   
     
    /// <summary>
    /// Deletes List<Typx> batch by query 
    /// </summary>
    /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
    Future<BoolResult> delete([bool hardDelete=false]) async {
      _buildParameters();
      var r= BoolResult();
        if(Typx._softDeleteActivated && !hardDelete) {
          r = await _obj._mnTypx.updateBatch(qparams,{"isDeleted":1}); }
      else {
          r = await _obj._mnTypx.delete(qparams); }
      return r;    
    }
     
    
     Future<BoolResult> update(Map<String, dynamic> values) {
       _buildParameters();
       return _obj._mnTypx.updateBatch(qparams, values);
     }
   
     /// This method always returns TypxObj if exist, otherwise returns null 
     /// <returns>List<Typx></returns>
     Future<Typx> toSingle([VoidCallback typx(Typx o)]) async{
       _pagesize = 1;
       _buildParameters();
       final objFuture = _obj._mnTypx.toList(qparams);
       final data = await objFuture;
       Typx retVal;
       if (data.isNotEmpty) { retVal = Typx.fromMap(data[0] as Map<String, dynamic>); } else {retVal = null;}
          if(typx!=null) {typx(retVal);}
       return retVal;
     }
     
   
      /// This method always returns int.
      /// <returns>int</returns>
      Future<BoolResult> toCount(VoidCallback typxCount (int c)) async {
       _buildParameters();
       qparams.selectColumns = ["COUNT(1) AS CNT"];   
       final typxsFuture = await _obj._mnTypx.toList(qparams);
       final int count = typxsFuture[0]["CNT"] as int;
       typxCount (count);
       return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
     }
      
     /// This method always returns List<Typx>. 
     /// <returns>List<Typx></returns>
     Future<List<Typx>> toList([VoidCallback typxList (List<Typx> o)]) async {
   
       _buildParameters();
       final typxsFuture = _obj._mnTypx.toList(qparams);
       final List<Typx> typxsData = List<Typx>();
       final data = await typxsFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           typxsData.add(Typx.fromMap(data[i] as Map<String, dynamic>));
         }
         if (typxList != null) typxList (typxsData);
         return typxsData;
     }
  
    
        /// Returns List<DropdownMenuItem<Typx>>
        Future<List<DropdownMenuItem<Typx>>> toDropDownMenu(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<Typx>> o)]) async {
          _buildParameters();
          final typxsFuture = _obj._mnTypx.toList(qparams);

          final data = await typxsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<Typx>> items = List();
          items.add(DropdownMenuItem(
            value: Typx(),
            child: Text("Select Typx"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: Typx.fromMap(data[i] as Map<String, dynamic>),
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }

        /// Returns List<DropdownMenuItem<int>>
        Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
            String displayTextColumn,
            [VoidCallback dropDownMenu(List<DropdownMenuItem<int>> o)]) async {
          _buildParameters();
          qparams.selectColumns=["idt",displayTextColumn];
          final typxsFuture = _obj._mnTypx.toList(qparams);

          final data = await typxsFuture;
          final int count = data.length;
          final List<DropdownMenuItem<int>> items = List();
          items.add(DropdownMenuItem(
            value: 0,
            child: Text("Select Typx"),
          ));
          for (int i = 0; i < count; i++) {
            items.add(
              DropdownMenuItem(
                value: data[i]["idt"] as int,
                child: Text(data[i][displayTextColumn].toString()),
              ),
            );
          }
          if (dropDownMenu != null) {
            dropDownMenu(items);
          }
          return items;
        }


     /// This method always returns Primary Key List<int>. 
     /// <returns>List<int></returns>
     Future<List<int>> toListPrimaryKey([VoidCallback idtList (List<int> o),
           bool buildParameters=true]) async {
       if(buildParameters) _buildParameters();
       final List<int> idtData = List<int>();
       qparams.selectColumns= ["idt"];
       final idtFuture = await _obj._mnTypx.toList(qparams);
   

         final int count = idtFuture.length;
         for (int i = 0; i < count; i++) {
           idtData.add(idtFuture[i]["idt"] as int);
         }
         if(idtList != null) {idtList (idtData);}
         return idtData;

     }
  
    /// Returns List<dynamic> for selected columns. Use this method for "groupBy" with min,max,avg.. 
    /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)  
     Future<List<dynamic>> toListObject([VoidCallback listObject(List<dynamic> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnTypx.toList(qparams);
   
       final List<dynamic> objectsData = List<dynamic>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i]);
         }
         if (listObject != null) {listObject(objectsData);}
         return objectsData;

     }

    /// Returns List<String> for selected first column
    /// Sample usage: await Typx.select(columnsToSelect: ["columnName"]).toListString()
     Future<List<String>> toListString([VoidCallback listString(List<String> o)]) async {
       _buildParameters();
   
       final objectFuture = _obj._mnTypx.toList(qparams);
   
       final List<String> objectsData = List<String>();
       final data = await objectFuture;
         final int count = data.length;
         for (int i = 0; i < count; i++) {
           objectsData.add(data[i][qparams.selectColumns[0]].toString());
         }
         if (listString != null) {listString(objectsData);}
         return objectsData;

     }
   }
   // endregion TypxFilterBuilder
       
       


// region TypxFields
class TypxFields {
  static TableField _fIdt;
  static TableField get idt {
    _fIdt = SqlSyntax.setField(_fIdt, "idt", DbType.integer);
    return _fIdt;
  }
  static TableField _fName;
  static TableField get name {
    _fName = SqlSyntax.setField(_fName, "name", DbType.text);
    return _fName;
  }
  static TableField _fType;
  static TableField get type {
    _fType = SqlSyntax.setField(_fType, "type", DbType.text);
    return _fType;
  }
  static TableField _fSubType;
  static TableField get subType {
    _fSubType = SqlSyntax.setField(_fSubType, "subType", DbType.text);
    return _fSubType;
  }
  static TableField _fNatural;
  static TableField get natural {
    _fNatural = SqlSyntax.setField(_fNatural, "natural", DbType.text);
    return _fNatural;
  }

}
// endregion TypxFields

//region TypxManager
class TypxManager extends SqfEntityProvider {
  TypxManager():super(DatabaseModel(),tableName: _tableName, colId: _colId);
  static String _tableName = "Typx";
  static String _colId = "idt";
 
}
//endregion TypxManager
